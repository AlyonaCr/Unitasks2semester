
#include <tchar.h>
//#include <stdexcept>
#include "myString3.h"
#include "Templates.h"
#include "MyStack.h"
#include "MyStack2.h"

#define stop __asm nop

int _tmain(int argc, _TCHAR* argv[])
{



	////////////////////////////////////////////////////////////////////////////
		//Тема. Шаблоны функций.
		//Создайте шаблон функции перестановки местами двух
		//значений - Swap(). Проверьте работоспособность созданного
		//шаблона с помощью приведенного ниже фрагмента кода.
		//Подсказка 1: объявление шаблона корректнее поместить в .h-файл.

	int iX = 1, iY = -1;
	Swap(iX, iY);

	double dX = 0.5, dY = -5.5;
	Swap(dX, dY);



	//Подсказка 2: подумайте, что нужно реализовать, для того,
	//			чтобы следующий вызов работал с объектами MyString
	//			не только корректно, но и эффективно
	// внутри класса MyString переопределение operator=

	MyString str1("One"), str2("Two");
	Swap(str1, str2);


	/////////////////////////////////////////////////////////////////////

		//Тема. Шаблоны классов.
		//Задание 1.
		//Создайте шаблон класса MyStack для хранения элементов любого типа T.
		//Подсказка: 1.элементы нужно где-то хранить - простым и удобным средством
		//			для хранения последовательно расположенных в памяти элементов
		//			является массив, 
		//			2.для задания максимального размера стека может быть использован
		//			параметр-константа шаблона
		//			3.обязательными операциями со стеком являются "push" и "pop". Для
		//			того, чтобы гарантировать корректное выполнение этих операций 
		//			хорошо было бы генерировать исключение в аварийной ситуации
		//			4. дополнительно реализуйте operator[] таким образом, чтобы пользователь   ---- ?
		//			мог читать/изменять значения только тех элементов, которые он формировал


		//С помощью шаблона MyStack создайте стек из 5 элементов int - iStack и
		//стек из 10 элементов MyString - strStack и поэкспериментируйте с функциями
		//push() и pop(), operator[]



	MyStack <int, 5> iStack;
	MyStack <MyString, 10> strStack;

	try {
		iStack.push(1);
		iStack.push(2);
		iStack.pop();
		for (size_t i = 0; i < iStack.GetCount(); i++) {
			cout << iStack[i] << endl;
		}
		iStack.push(3);
		iStack.push(4);



		strStack.push("One");
		strStack.push("Two");
		strStack.push("Three");
		for (size_t i = 0; i < iStack.GetCount(); i++) {
			cout << strStack[i] << endl;
		}
		strStack.pop();
		for (size_t i = 0; i < strStack.GetCount(); i++) {
			cout << strStack[i] << endl;
		}

		//exeptions
		strStack.pop();
		strStack.pop();
		strStack.pop();

	}
	catch (const char* error) {
		cout << error << endl;
	} 

	try{
		iStack.push(4);
		iStack.push(4);
		iStack.push(4);
	}
	catch (const char* error) {
		cout << error << endl;
	}


		//Задание 2. Реализуйте шаблон стека - MyStack2 таким образом, чтобы 
		//для хранения элементов использовался ОДНОСВЯЗНЫЙ список.
		//Реализуйте возможность распечатать элементы стека в том порядке, в котором их заносил (push())
		//пользователь

	MyStack2 <MyString> st1;
	st1.push("A");
	st1.push("B");
	st1.push("C");
	st1.push("D");
	st1.Print();
	st1.pop();
	st1.Print();

	cout << st1.top() << endl;
	MyStack2 <MyString> st2(st1);



		//Задание 3. Реализуйте шаблон очереди - MyQueue таким образом, чтобы 
		//для хранения элементов использовался динамический массив.
		//При использовании массива следует учесть специфику очереди, то есть
		//когда заполнен "хвост", в "голове" скорее всего уже имеются свободные элементы
		//=> должен быть организован кольцевой буфер



	return 0;
}

