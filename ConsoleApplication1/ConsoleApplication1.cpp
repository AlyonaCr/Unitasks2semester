#include "myRect.h"
#include "myString.h"
#include <iostream>
#include "Burrel.h"

#define stop __asm nop

void main()
 {
	using namespace std;
	
		//Задание 1.Объявление класса. Создание экземпляра класса.
		//Вызов методов класса.
		//Откройте закладку Class View - (здесь Вы увидите имена методов и
		//данных - классов Rect и MyString)
		//Обратите внимание на пиктограммы слева от имен членов класса - они
		//обозначают спецификатор доступа к каждому члену класса. -- private

		//Какой конструктор вызывается при создании экземпляра класса?
		// Вызывается автоматический конструктор, объект локальный, данные членов класса остались непроинициализированы
		// После создания конструктора с параметрами, система уведомляет, что конструктора по умолчанию нет и требуется добавить дефолтный конструктор
		{
			Rect rect;
			stop
		}

		//1a. Объявите и определите конструктор с параметрами для
		//инициализации переменных класса. Создайте экземляры класса Rect
		//с помощью конструктора с параметрами. Если компилятор выдает
		//ошибку в предыдущем фрагменте, подумайте - чего ему не
		//хватает? Добейтесь отсутствия ошибок.								---- Для предыдущего фрагмента нужен констурктор по умолчанию
		//Выполняя задание с самого начала по шагам, определите:
		//в какой момент происходит вызов конструктора(какого?)?
		{
			Rect rect (1, 6, 1, 4);
		stop
		}


		
		//1б. При конструировании объекта посредством конструктора без параметров
		//предусмотрите инициализацию переменных класса, например, нулем			---- Нулем нельзя, т.к. реализована проверка значений, а хочется 
																						//конструктор с параметрами по умолчанию

		/*См. myRect.cpp*/

		//1в. Подумайте, как следует поступать в случае, когда пользователь задал
		//координаты следующим образом:

		Rect rrr(4,3,2,1);     /* ---- Требуется проверка коректности значений в конструкторе и нормализация*/

		stop
			//1г. Объявите, определите и вызовите метод класса InflateRect(),
			//который увеличивает размеры прямоугольника на заданные приращения
			//(раздвигая стороны от центра - каждую сторону на свое значение).
			//Подсказка: объявить и определить методы можно не только "вручную",
			//но и с помощью Wizard-a Class View. Для этого: откройте закладку
			//ClassView окна проекта, сделайте активным класс Rect и нажмите
			//правую кнопку мыши - в появившемся контекстном меню выберите
			//Add/Add Member Function... С помощью появившейся диалоговой панели
			//"дайте указания" Wizard-у как объявить и определить метод.
			Rect rect(1, 6, 1, 4);
			rect.InflateRect(1, 1, 1, 1);


		stop
	
	
		//Задание 2.Перегрузка конструкторов и методов класса.
		//Конструктор копирования.

		//2а.Объявите и определите конструктор копирования в классе Rect.
		//Выполняя задание по шагам, определите, какой
		//конструктор вызывается при создании r1,r2,r3 и r4?
		//Чему равны переменные созданных объектов?
			Rect r1;  // конструктор по умолчанию
			Rect r2(1,2,3,4); // конструктор с параметрами, но это квадрат, срабатывает защита и в итоге в r2 мусор
			Rect r3 = r1;	// конструктор копирования
			Rect r4(r2);	// тоже конструктор копирования, но в r2 мусор, поэтому в r4 теперь тоже мусор
			stop


	 // //2б. Объявите и определите в классе Rect метод InflateRect(),
		////который принимает два аргумента, по умолчанию равных 1, и
		////раздвигает стороны прямоугольника на на заданные приращения.
		////Для каких объектов вызывается функция InflateRect()?		--- Для тех, что были инициализированы в задание 2а
			r1.InflateRect(1,1);
			r2.InflateRect(2,2);			// r2 была инициализирована мусором, поэтому мусор получился в итоге
		//Какая из функций InflateRect() вызывается в каждом из трех случаев? -----  r1-r2 - там, где 2 аргумента
			r3.InflateRect(2,2,2,2);											// 4 агрумента
			r3.InflateRect(3,3);												// здесь и далее метод с 2 аргументами
			r3.InflateRect(5);
			r3.InflateRect();													
		stop
	

	
		//Задание 3.Спецификаторы доступа. Инкапсуляция.
		{
		Rect r;
		//Раскомментируйте следующую строку. Объясните ошибку
		//компилятора
/*
		int tmp = r.m_left;			спецификатор доступа private, обратиться напрямую к этому члену нельзя*/



		//Введите в класс Rect метод void SetAll(...),
		//который присваивают переменным класса передаваемые
		//значения. Вызовите созданный метод, проверьте корректность.
		r.SetAll(1, 5, 1, 3);


		//Введите в класс Rect парный метод GetAll(...),				---- что значит "достает"? выводит на экран или присваивает другому объекту?
		//который "достает" значения private-переменных класса.
		//Вызовите созданный метод, проверьте корректность.

		
		int x1, y1, x2, y2;
		r.GetAll(x1, x2, y1, y2);
		stop
		}
	
	
		//Задание 4.Передача экземпляра класса в качестве параметра
		//функции. Возвращение объекта класса по значению. Поставив
		//остановы в конструкторе копирования или выполняя фрагмент
		//по шагам, определите: в какой момент происходит обращение
		//к конструктору копирования.
		//Создайте глобальную функцию
		// Rect BoundingRect(Rect, Rect);
		//которая принимает два объекта класса Rect по значению и
		//возвращает объект класса Rect, который является прямоугольником,
		//в который вписаны заданные прямоугольники. Как происходит
		//передача параметров и возвращение объекта класса?

		//Замечание*: хорошо было бы учесть тот факт, что прямоугольник
		//может оказаться "ненормализованным", то есть m_left>m_right или/и
		//m_top>m_bottom

		{
			
			Rect r1(1,2,3,4), r2(5,6,7,8),r3;
			r3.BoundingRect(r1, r2);
			Rect r4(1, 2, 3, 4), r5(7, 8, 9, 10);
			Rect r6 = GlobalBoundingRect(r4, r5);
		stop

		//Задание 4а. Передача объектов по ссылке.
		//Создайте глобальную функцию BoundingRect2, которая выполняет ту же
		//задачу, принимая параметры по ссылке
		//Вызываются ли конструкторы при передаче параметров?


		r3.BoundingRect2(r1, r2);
		stop
		}

	

	
		//Задание 5. Указатель на класс. Объявите и определите
		//явный деструктор класса. Поставьте остановы в
		//конструкторе (конструкторах) и деструкторе. Определите: когда для
		//каждого из объектов вызывается конструктор, а когда - деструктор?

		// Вопрос: класс простой, специфических действий выполнять не нужно, зачем явный деструктор?
		{
			Rect r1;
			Rect*	pR = new Rect(1,2,1,2);
			{
				Rect r2(r1);
				Rect arRect[2];
				for(int i=0; i<3; i++)
				{
					static Rect r3 (i,i,i,i) ;
					Rect r4(*pR);
					Rect r5(i,i,i,i);
				}
			}
			delete pR;
			stop
		}
	
	
		//Задание 6.Конструктор + деструктор = функциональное
		// замыкание. Класс MyString
		// Посредством конструктора (конструкторов) и деструктора обеспечьте
		//корректные инициализацию и деактивацию объекта
		//C помощью остановов определите когда происходит
		//захват и освобождение памяти для строки-члена класса
		{
			MyString str ("It's my string!");			// Захват памяти
			//Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
			//С помощью cout и метода GetString() распечатайте строку объекта str
			//Замечание: подумайте, как следует корректно реализовать метод GetString().
			const char* p = str.GetString();

			const MyString str1(" my string!");
			const char* p1 = str1.GetString();
			cout << p << '\n';
				
			
		} // вызывается деструктор
		stop
	
	
		//6a. Раскомментируйте следующий фрагмент. Подумайте - какие
		//неприятности Вас ожидают. Попробуйте исправить положение (как?)
		{
			MyString str1("The first string!");
			MyString str2 = str1; // "сиамские близнецы", получат ссылку на один и тот же участок памяти. нужно переопределить метод копирования
		}
			stop

			//6б. Реализуйте метод SetNewString, который будет заменять строку
			// на новую

		{
			MyString str("Before replacement");
			str.SetNewString("After replacement");
			char pp[] = { "ABCD" };
			str.SetNewString(pp);

		}



			//6г. Создайте глобальную функцию, которая будет принимать любое
			//количество указателей на строки, а возвращать объект MyString,
			//в котором строка будет конкатенацией параметров

			// cпросить про стоповый символ
		{
			MyString str = MyStrConcat("abc", "123", "qwerty", nullptr);

			stop
			}

	
		//Задание 7.Массив объектов класса.
		{
		//Объявите и проинициализируйте массив ar из объектов
		// типа MyString. Например:
		//Как задать размерность? N=3

			const int N = 3;

			MyString arstr[N] = { MyString("First"), MyString("Second"), MyString("Third") };


		//Проверка - печать строк-членов класса
			size_t cap = sizeof(arstr) / sizeof(MyString);
			for (int i = 0; i < cap; i++) {
				cout << arstr[i].GetString()<< " ";
			}
			cout << '\n';

		//Увеличьте размер массива, не изменяя список инициализаторов:
		//N=5???
			const int NN = 5;

			MyString *str = new MyString[NN];
			for (int i = 0; i < N; i++) {
				str[i] = arstr[i];
			}


		//Объявите и проинициализируйте массив объектов	типа Rect.
			Rect m_rect[NN] = { Rect(1,4,1,3), Rect(1,7,4,7) }; // остальные инициализируются по умолчанию


		}
		stop
	
	
		//Задание 8.Массив указателей на объекты класса.
		{
			//Объявите и проинициализируйте массив arPtr из трех
			//указателей на объекты типа MyString.
			const int N = 3;
			MyString* arPtr[N] = {new MyString("First"),new MyString("Second"), new MyString("Third") };


			////Печать строк-членов класса
			for (int i = 0; i < N; i++) {
				cout << arPtr[i]->GetString()<< " ";;
			}
			cout << '\n';
		}
		stop
	
	//Задание 9.  Решите с помощью классов следующую задачу:
	//даны две бочки известного объема. В одной бочке в начальный момент
	//времени содержится спирт (96%), в другой – вода.
	//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
	//в другую следующим способом: на каждой итерации
	//зачерпнули из первой бочки -> вылили во вторую
	//зачерпнули из второй бочки -> вылили в первую.
	//Требуется определить номер итерации, на которой концентрация спирта в
	//первой бочке станет меньше 50%.

	Burrel spirit (120, 96);
	Burrel water(100, 100);
	int iter_counter = 0;
		
		while(spirit.GetConcentrate() > 50)
		{
			spirit.Pour(water); //или spirt.Pereliv(water, объем_кружки);
			water.Pour(spirit); // аналогично
			iter_counter++;
		}
		printf_s("Spirit gets %fl concentration in %d iterations", spirit.GetConcentrate(), iter_counter);
	
		stop
}//end_main


