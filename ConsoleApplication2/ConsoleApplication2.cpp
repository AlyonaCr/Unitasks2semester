
#include "pch.h"
#include <iostream>
#include <tchar.h>
#include "Shape.h"
#include "Rect.h"
#include "Circle.h"
#include <iostream>
#include "MyByte.h"
#include "Hex.h"
#include "Oct.h"
#include "Bin.h"

#define	  stop __asm nop

using namespace std;
int _tmain(int argc, _TCHAR* argv[])
{



	//Задание 1.Простое наследование.Аргументы конструктора,
	// передаваемые в базовый класс.

	//Создайте иерархию классов:
	//базовый класс Shape (который описывает любую фигуру)
	//и два производных класса Rect и Circle.
	//Подумайте: какие данные и методы нужно ввести в базовый
	//и производные классы (например, любую фигуру можно сделать
	//цветной => в базовом классе можно ввести переменную, которая
	//будет определять цвет фигуры.
	//Подсказка: для хранения цвета объявите перечисление (RED,GREEN,BLUE...);



	//В конструкторах производных классов предусмотрите передачу
	//параметра-цвета конструктору базового класса.
	//При создании и уничтожении объекта производного типа определите
	//последовательность вызовов конструкторов и деструкторов базового
	//и производного классов

	Circle *circle = new Circle(RED, "Me", 2.5);
	circle->SetAuthor("Not me");
	delete circle;
	circle = nullptr;

	/*
	При создании объекта:
	1. Передача управления конструктору производного класса (Circle), пока ничего не присваевает.
	2. Передача управления конструктору базового класса (Shape), присваивает значения членам базового класса.
	3. Передача управления конструктору проивзодного класса (Cirlce), присваивает значения членам производного класса.
	4. Передача управления вызывающей функции

	При удалении:
	1. Передача управления автоматическому деструктору производного класса (Circle).
	2. Автоматический деструктор производного класса вызывает деструктор базового класса (Shape).
	3. Свобождение в деструкторе базового класса динамически захваченной памяти под член класса (char* m_author).
	*/


	stop
		//////////////////////////////////////////////////////////////////////

			//Задание 2.Виртуальные функции.
			//2а) Модифицируйте классы Shape,Rect и Circle:
			//добавьте в каждый класс public метод void WhereAmI().
			//Реализация каждой функции должна выводить сообщение
			//следующего вида "Now I am in class Shape(Rect или Circle)".
			//Выполните приведенный фрагмент, объясните результат.

			//2б) Сделайте метод WhereAmI() виртуальным.
			//Снова выполните приведенный фрагмент, объясните разницу.

	{
		/*Shape s(RED, "Frank");*//* -----	Невозможно создать объект абстрактного класса*/
		Rect r(GREEN, "Mary", 1, 5, 1, 4);
		Circle c(BLUE, "Katy", 2.7);


		//Метод какого класса вызывается в следующих строчках???
		/*s.WhereAmI();	//	Shape (до виртуализации метода)   ПОСЛЕ: Невозможно создать объект абстрактного класса*/
		r.WhereAmI();	//	Rect
		c.WhereAmI();	//	Circle
		stop

			/*Указатель на объект класса Shape, поэтому вызывается метод из класса Shape. Если бы метод был виртуальным, то вызывался бы метод
			целвого класса*/
			/*Shape* pShape = &s; */  // ПОСЛЕ ВИРТУАЛИЗАЦИИ МЕТОДА: Невозможно создать объект абстрактного класса
			Shape* pRect = &r;
			Shape* pCircle = &c;
			/*pShape->WhereAmI();*/	//	Shape   ПОСЛЕ ВИРТУАЛИЗАЦИИ МЕТОДА: Невозможно создать объект абстрактного класса
			pRect->WhereAmI();	//	Shape
			pCircle->WhereAmI(); //	Shape
			stop


				//Заполните ... согласно комментариям
				/*Shape& rShape = s; *///псевдоним s					тоже самое
				Shape& rRect = r; //псевдоним r
				Shape& rCircle = c; //псевдоним c
				/*rShape.WhereAmI();*/	//вызов посредством rShape	----> Shape             тоже самое
				rRect.WhereAmI();	//вызов посредством	rRect	----> Shape
				rCircle.WhereAmI(); //вызов посредством rCircle	----> Shape
				stop


					/*ОБЪЯСНЕНИЕ:
					До виртуализации метода WhereAmI(), при возове этого метода для указателей класса Shape, указывающих на Circle и Rect, производился вызов
					функции класса указателя.
					После виртуализации метода WhereAmI(), во-первых, класс Shape стал асбтрактным , так как использовалась чистая виртуализация, и компилятор
					больше не допускает создания экземпляров данного класса, во-вторых, в объектах производных классов появилась дополнительная информация, а именно:
					служебное поле для хранения указателя на таблицу виртуальных функций vtab- _vfptr, которая создается для базового и производных классов. На этапе
					выполнения программы по данному указателю производится вызов соответсвующей классу функции.
					*/
	}


		//////////////////////////////////////////////////////////////////////

			//Задание 3.Виртуальные деструкторы.
			//Модифицируйте классы:
			//a) введите соответствующие
			// деструкторы (без ключевого слова virtual).
			//Реализация каждого деструктора
			//должна выводить сообщение следующего вида
			// "Now I am in Shape's destructor!" или
			// "Now I am in Rect's destructor!"
			//Выполните фрагмент. Объясните результат.

			// b) Добавьте в объявление деструкторов ключевое слово virtual
			//Выполните фрагмент.Объясните разницу.


			////Подумайте: какие конструкторы вызываются в следующей строке?
			//	//Если в разработанных классов каких-то конструкторов
			//	//не хватает - реализуйте
			//	//Если Вы считаете, что в приведенном фрагменте чего-то
			//	//не хватает - добавьте
			//
				Rect r(GREEN, "Mary", 1, 5, 1, 4);
				Shape* ar[]={/*new Shape(r),*/ new Rect(r), new Circle(r), new Circle() };
			//	//Вызовите для каждого элемента массива метод WhereAmI()

				
				for (int i = 0; i < 3; i++) {
					ar[i]->WhereAmI();
				}

				for (int i = 0; i < 3; i++) {
					delete ar[i];
				}
				
				/* Пока не добавили виртуальный деструктор, при удалении вызывается только деструктор базового класса
				После добавления виртуального деструктора в базовый класс, при удалении сначала вызывается деструктор производного класса, а затем базового*/
	
					stop



					//Задание 4*. В чем заключается отличие 1) и 2)
				{

					Shape* pShapes = new Rect[10];//1) указатель на объект класса Shape
					Rect* pRects = new Rect[10];//2) указатель на объект класса Rect
					/*Разница в том, что при несоотвествующем типе указателя некорректно вычисляется адрес экземпляра класса, что приводит к ошибкам на этапе
					компиляции*/

					//Попробуйте вызвать метод WhereAmI() для каждого элемента обоих массивов -
					//в чем заключается проблема???
					/*Проблема в неправильном типе указателя и некорректном вычислении адреса*/

					cout << "pShapes" << '\n';
					int cap = 10;
					for (int i = 0; i < cap; i++) {
						static_cast<Rect*>(pShapes)[i].WhereAmI();
					}
					cout << "pRects" << '\n';
					for (int i = 0; i < cap; i++) {
						pRects[i].WhereAmI();
					}

					//Освободите динамически захваченную память
					delete[] pShapes;
					/*Тут та же проблема с некорретным вычислением адреса*/
					delete[] pRects;
					stop


				}
		

		//////////////////////////////////////////////////////////////////////
	
			//Задание 5.Виртуальные функции и оператор разрешения области видимости.

			{
				Rect r(GREEN, "Mary", 1, 5, 1, 4);
				Shape* p = &r;
				p->WhereAmI();//...
				stop


					/*4a Оператор разрешения области видимости.
					Посредством объекта r и указателя p вызовите виртуальную функцию
					WhereAmI()класса Shape*/
					p->Shape::WhereAmI();

				stop
			}
	

		//////////////////////////////////////////////////////////////////////
		
			//Задание 6.Чисто виртуальные функции.
			//Введите в базовый класс метод void Inflate(int); Подумайте:
			//можно ли реализовать такой метод для базового класса? => как его нужно объявить.  -----	Чисто виртуальный метод
			//Реализуйте этот метод для производных классов.
			{
				Rect r;			// вызов конструктора по умолчанию
				Shape* p = &r;
				p->Inflate(5);
				Circle c;		// вызов конструктора по умолчанию
				p = &c;
				p->Inflate(5);
			}
		

		//////////////////////////////////////////////////////////////////////
		/*
			//Задание 7.Объединения (union) C++. Битовые поля.
			//1.
			//Создайте следующие классы для различных представлений значений байта:
			//Bin - для двоичного представления
			//Hex - для шестнадцатерчного представления
			//Oct - для восьмеричного представления.
			//Подсказка 1: - для удобства используйте битовые поля.
			//Подсказка 2: - конструкторов в таких вспомогательных классах быть не должно,
			//так как все они будут членами объединения (union).
			//2.
			//В каждом классе введите метод Show, который должен выводить значение в
			//соответствующем виде
			//3.
			//Посредством объединения MyByte предоставьте пользователю возможность манипулировать
			//одним и тем же значением по-разному:
			//а) выводить: десятичное, шестнадцатеричное, восьмеричное, двоичное значение байта
			//          а также символ, соответствующий хранимому значению (если есть соответствие);
			//б) выводить отдельные (указанные посредством параметра) шестнадцатеричные,
			//			восьмеричные, двоичные цифры;
			//в) изменять отдельные двоичные, восьмеричные или шестнадцатеричные цифры;
			*/

			MyByte byte(0xef);
			byte.ShowHex();
			byte.ShowBin();
			byte.ShowOct();
	



		return 0;
}//endmain

